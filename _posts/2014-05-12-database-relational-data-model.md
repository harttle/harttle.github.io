---
layout: blog
title:  关系数据模型

tags: 数据库
---

本文给出了关系数据模型中各部分的定义，以及模型中存在的约束。
接着给出在该模型上的关系代数及其演算。

<!--more-->

# 关系数据模型与约束

定义：表为**关系**，行为**元组**，列标题为**属性**，值域为**域**，关系R为**关系内含**，其状态r(R)为**关系外延**。关系的另外一种定义：元组为域之间的映射，每个角色都是键值对，此时元组是无序的。

数据库约束分为3类：**隐式约束**为固有的基于模型的约束；**显式约束**为基于模式的约束（DDL定义）；**语义约束**为基于应用的约束，又称业务规则。另一类重要的约束为**数据依赖**，包括函数依赖和多值依赖。以下属于基于模式的约束：

1. 域约束。域的数据类型。
2. 键约束。超键（superkey）唯一性约束，候选键中选一个主键来标识元组。
3. 实体完整性约束。主键不为NULL。
4. 参照完整性约束。参照的必须是存在的元组。

另外，还包括语义完整性约束、函数依赖约束。除了如上的状态约束，还包括**变迁约束**。

对于更新时的违例约束有多种处理：

1. 插入。拒绝、修正拒绝插入的原因（级联）
2. 删除。拒绝、级联删除、置空或默认值
3. 更新。非主键非外键时不会有问题。

# 关系代数与关系演算

**关系代数**运算：

运算 | 用途 | 表示法
--- | --- | ---
选择 | 选择满足条件的元组 | $\sigma_{\<select~cond\>}(R)$
投影 | 只选择指定的属性   | $\pi_{\<propperty~list\>}(R)$
连接 | 关系$R_1$和$R_2$中满足连接条件的元组 | $R_1\bowtie_{\<join~cond\>} R_2$
等值连接 | 上述运算的条件中只作相等判断 | $R_1\bowtie_{\<join~cond\>} R_2$
自然连接 | 消除等值连接中重复字段 | ${R_1}_{\*\<join~cond\>} R_2$
并  | 取并集 | $R_1\cup R_2$
交  | 取交集 | $R_1\cap R_2$
差  | 取差集 | $R_1 - R_2$
笛卡尔积 | 生成一个关系，其包含两者的所有属性，两者的所有组合 | $R_1 \times R_2$
除 | 生成一个关系，其中元组与$R_2$的每一组合都出现在$R_1$中 | $R_1(Z) \div R_2(Y)$

其他关系代数运算包括：

1. 广义投影。将属性的函数包含在投影列表中。
2. 聚集函数。对元组信息进行汇总。$$_{<group~propperty>}\Im_{<function~list>}(R)$$
3. 递归闭包。应用与同类型元组间的递归联系。
4. 外连接。左外连接将包括左元的所有元组，右外连接将包括右元的所有元组。
5. 外并。将并运算作用于部分相容的两个关系。

*查询树*为一个与关系代数表达式对应的树状数据结构。其输入关系作为叶节点，关系代数运算作为中间节点。

**关系演算**包括元组关系演算和域演算。**元组关系演算**的一般表达式为
$$\{t_1.A_j, t_2.A_k, ..., t_n.A_m|COND(t_1, t_2, ...,t_{n+m})\}$$。
公式中可以包括*全称量词*
$$\forall$$，
和*存在量词*
$$\exists$$。
**域演算**的变量为单个属性而非元组，其一般表达式为
$$\{x_1,x_2,...,x_n | COND(x_1,x_2,...,x_{n+m})\}$$。

*安全表达式*保证得到的结果是有限数目的元组。

